<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中的自动装箱与拆箱</title>
      <link href="posts/1ca5350f.html"/>
      <url>posts/1ca5350f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、-什么是自动装箱拆箱"><a href="#一、-什么是自动装箱拆箱" class="headerlink" title="一、 什么是自动装箱拆箱"></a>一、 什么是自动装箱拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer total = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> totalprim = total;</span><br></pre></td></tr></table></figure><p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p><p>下面我们来看看需要装箱拆箱的类型有哪些：<br><img src="https://i.loli.net/2021/04/28/wUJGdbE7B5lzP8L.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:left">基本数据类型</th><th style="text-align:left">包装器类型</th></tr></thead><tbody><tr><td style="text-align:left">int（4字节）</td><td style="text-align:left">Integer</td></tr><tr><td style="text-align:left">short（2字节）</td><td style="text-align:left">Short</td></tr><tr><td style="text-align:left">long（8字节）</td><td style="text-align:left">Long</td></tr><tr><td style="text-align:left">float（4字节）</td><td style="text-align:left">Float</td></tr><tr><td style="text-align:left">double（8字节）</td><td style="text-align:left">Double</td></tr><tr><td style="text-align:left">char（2字节）</td><td style="text-align:left">Character</td></tr><tr><td style="text-align:left">boolean（未定）</td><td style="text-align:left">Boolean</td></tr></tbody></table></div><p>这个过程是自动执行的，那么我们需要看看它的执行过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//自动装箱</span></span><br><span class="line">  Integer total = <span class="number">99</span>;</span><br><span class="line">  <span class="comment">//自动拆箱</span></span><br><span class="line">  <span class="keyword">int</span> totlaprim = total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>反编译class文件之后得到如下内容：<code>javap -c StringTest</code></p><p><img src="https://i.loli.net/2021/04/28/eCzXj3amIDrqbUB.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer total = <span class="number">99</span>;</span><br></pre></td></tr></table></figure><br>执行上面那句代码的时候，系统为我们执行了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer total = Integer.valueOf(<span class="number">99</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalprim = total;</span><br></pre></td></tr></table></figure><p>执行上面那句代码时，系统为我们执行了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalprim = total.intValue();</span><br></pre></td></tr></table></figure></p><p>我们现在就以Integer为例，来分析一下它的源码：</p><ol><li><p>首先来看看<code>Integer.valueOf</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(ini i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i &gt;= <span class="number">128</span> || i &lt; -<span class="number">128</span> ? <span class="keyword">new</span> Integer(i) : SMALL_VALUES[i + <span class="number">128</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行<code>SMALL_VALUES[i+128]</code><br>首先我们来看看Integer的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String string)</span> <span class="keyword">throws</span> NumbeFormatException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(parseInt(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它里面定义了一个value变量，创建一个Integer对象，就会给这个变量初始化。第二个传入的是一个String变量，它会先把它转换成一个int值，<br>下面看看<code>SMALL_VALUES[i+128]</code>是什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> statis <span class="keyword">final</span> Integer[] SMALL_VALUES = <span class="keyword">new</span> Integer[<span class="number">256</span>];</span><br></pre></td></tr></table></figure><p>它是一个静态的integer数组对象，也就是说最终valueOf返回的都是一个Integer对象。<br>所以我们这里可以总结一点：<br><u>装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响内存。</u></p></li><li><p>接着看看intValue函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单，直接返回value值即可。</p></li></ol><h3 id="二、-相关问题"><a href="#二、-相关问题" class="headerlink" title="二、 相关问题"></a>二、 相关问题</h3><p>上面我们看到在Integer的构造函数中，它分为两种情况：</p><ol><li>i &gt;= 128 || i &lt; -128 =====&gt; new Integer(i)</li><li>i &lt; 128 &amp;&amp; i &gt;= -128 ====&gt; SMALL_VALUES[i + 128]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer[] SMALL_VALUES = <span class="keyword">new</span> Integer[<span class="number">256</span>];</span><br></pre></td></tr></table></figure>SMALL_VALUES本来已经被创建好，也就是说在i &gt;= 128 || i &lt; -128时会创建不同的对象， 在i &lt; 128 &amp;&amp; i &gt;= -128 会根据i的值返回已经创建好的指定的对象。</li></ol><p>说这些可能还不是很明白，下面我们来举个例子吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">    System.out.println(i1 == i2);  <span class="comment">//true</span></span><br><span class="line">    System.out.println(i3 == i4);  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码的后面，我们可以看到它们的执行结果是不一样的，为什么。再看看我们上面的说明。</p><ol><li>i1和i2会进行自动装箱，执行了valueOf函数，它们的值在[-128, 127]这个范围内，它们会拿到SMALL_VALUES数组里面的同一个对象SMALL_VALUES[228], 它们引用到了同一个Integer对象，所以它们肯定是相等的。</li><li>i3和i4也会自动装箱，执行了valueOf函数，它们的值大于127，所以会执行new Integer(200)，也就是说它们会分别创建两个不同的对象，所以它们肯定不等。<br>下面我们来看看另外一个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">    System.out.println(i1==i2); <span class="comment">//false</span></span><br><span class="line">    System.out.println(i3==i4); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>看看上面的执行结果，跟Integer 不一样，这样也不必奇怪，因为它们的valueOf实现不一样，结果肯定也不一样，那为什么它们不统一一下呢？<br>这个很好理解，因为对于Integer， 在[-128, 127]之间只有固定的256个值，所以为了避免多次创建对象，我们事先先创建好一个大小为256的Integer数组SMALL_VALUES, 所以如果值在这个范围内，就可以直接返回我们事先创建好的对象就可以了。</li></ol><p>但是对于Double类型来说，我们就不能这么做，因为它在这个范围内个数是无限的。<br>总结一句就是：<u>在某个范围内的整型数值的个数是有限的，而浮点数却不是。</u></p><p>所以在Double里面的做法很直接，就是直接创建一个对象所以每次创建的对象都不一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面我们进行一个归类：<br>Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。<br>Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。<br>下面对Integer派别进行一个总结，如下图：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">相同对象范围</th><th style="text-align:left">不同对象范围</th></tr></thead><tbody><tr><td style="text-align:left">Integer</td><td style="text-align:left">[-128, 128)</td><td style="text-align:left">i &gt;= 128 &#124;&#124; i &lt; -127</td></tr><tr><td style="text-align:left">Short</td><td style="text-align:left">[-128, 128)</td><td style="text-align:left">s &gt;= 128 &#124;&#124; i &lt; -127</td></tr><tr><td style="text-align:left">Integer</td><td style="text-align:left">c &lt;  128</td><td style="text-align:left">c &gt;= 128</td></tr><tr><td style="text-align:left">Long</td><td style="text-align:left">[-128, 128)</td><td style="text-align:left">v &gt;= 128 &#124;&#124; i &lt; -127</td></tr></tbody></table></div><p>下面我们来看一看另外一种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1==i2);  <span class="comment">//true</span></span><br><span class="line">    System.out.println(i3==i4);  <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到返回的都是true， 也就是它们执行valueOf返回的都是相同的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(Boolean b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到他并没有创建对象，因为在内部已经提前创建好两个对象，因为它只有两种情况， 这样也是为了避免重复创建太多的对象。</p><p>上面把几种情况都介绍到了，下面来进一步讨论其他情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(num1 == num2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>说明 num1 == num2进行了拆箱操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">System.out.println(num1.equals(num2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>我们先来看看equals源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (o <span class="keyword">instanceof</span> Integer) &amp;&amp; (((Integer) o).value == value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们指定equal比较的是内容本身，并且我们也可以看到equal的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">Long num3 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(num1 + num2);    <span class="comment">//200</span></span><br><span class="line">System.out.println(num3 == (num1 + num2));    <span class="comment">//true 自动拆箱</span></span><br><span class="line">System.out.println(num3.equals(num1 + num2));    <span class="comment">//false</span></span><br></pre></td></tr></table></figure><br><u>1. 当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。</u><br><u>2. 对于num3.equals(num1+num2)为false的原因很简单，我们还是根据代码实现来说明：</u><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (o <span class="keyword">instanceof</span> Long) &amp;&amp; (((Long) o).value == value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它必须满足两个条件才为true：</p><ol><li>类型相同 （上面返回false的原因就是类型不同）</li><li>内容相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">100</span>;</span><br><span class="line">Integer num2 = <span class="number">200</span>;</span><br><span class="line">Long num3 = <span class="number">300</span>;</span><br><span class="line">System.out.println(num3 == (num1 + num2));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>我们来反编译一下这个class文件，<code>javap -c StringTest</code></li></ol><p><img src="https://i.loli.net/2021/04/28/IqBXjsmQ2ylz8wT.png" alt=""><br>可以看到运算的时候首先对num3进行拆箱（执行num3的longValue得到基础类型为long的值300），然后对num1和num2进行拆箱（分别执行了num1和num2）然后进行相关的基础运算。<br>我们来对基础类型进行一个测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">long</span> num3 = <span class="number">300</span>;</span><br><span class="line">System.out.println(num3 == (num1 + num2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>上面就说明了为什么最上面会返回true。<br>所以，当”==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算数运算）则比较的是数值（即会触发自动拆箱的过程）。</p><p>通过上面的分析我们需要知道两点：</p><ol><li>什么时候会引发装箱和拆箱</li><li>装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。</li><li>equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱。</li><li>当两种不同类型用”\==”比较时，包装器类的需要拆箱，当同种类型用”\==”比较时，会自动拆箱或装箱。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存机制 </tag>
            
            <tag> 自动拆装箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级操作系统 No.1</title>
      <link href="posts/f3e88753.html"/>
      <url>posts/f3e88753.html</url>
      
        <content type="html"><![CDATA[<h3 id="知人不评人"><a href="#知人不评人" class="headerlink" title="知人不评人"></a><strong>知人不评人</strong></h3><ul><li>轻易地给一个人下定论，对别人是一种伤害，更是一种不公平。</li></ul><h3 id="知事不声张"><a href="#知事不声张" class="headerlink" title="知事不声张"></a><strong>知事不声张</strong></h3><ul><li>知事不声张，既会保全别人的体面，又能周全自己的修养。</li><li>因为尊重，所以不拆穿；因为慈悲，所以不忍他难堪。 </li><li>人生在世，各有各的光鲜，各有各的苦衷。</li><li>不道破别人的心思，是将心比心的情商；不触碰别人的伤疤，是不动声色的善良。</li><li>知事不声张，对自己而言，是举手之劳；对别人而言，却是莫大的幸运。</li></ul><h3 id="知理不争辩"><a href="#知理不争辩" class="headerlink" title="知理不争辩"></a><strong>知理不争辩</strong></h3><ul><li>观点不同，相互尊重；层次不同，无需争辩。 </li><li>在不痛不痒的小事上，较高下，必定拉低自己的格局；在鸡毛蒜皮的琐碎上，辨输赢，终将耗费自己的心力。</li><li>用豁达化解是非，用沉默减少冲突。真正的聪明人都懂的：有一种豁达叫“知理不争辩”；有一种智慧叫“得理也饶人”。</li><li>《庄子》里说：“<strong>井蛙不可语海，夏虫不可语冰。</strong>”意思：对井里的蛙不可与它谈论关于海的事情，是由于它的眼界受到狭小居处的局限；对夏天生死的虫子不可谈论关于冰雪的事情，是由于它的眼界受到时令的制约。</li><li>喋喋不休，不如就此打住；斤斤计较，不如一笑而过。</li><li><strong>欲成大树，莫与草争。将军有剑，不斩苍蝇。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人间感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test-mathjax</title>
      <link href="posts/1329187c.html"/>
      <url>posts/1329187c.html</url>
      
        <content type="html"><![CDATA[<p>$x\in X_1P_s(Y|X=x)=P_t(Y|X=x)$</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中的Normalization</title>
      <link href="posts/e7d825a5.html"/>
      <url>posts/e7d825a5.html</url>
      
        <content type="html"><![CDATA[<p>来源丨<a href="https://zhuanlan.zhihu.com/p/33173246">https://zhuanlan.zhihu.com/p/33173246</a></p><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>  深度神经网络模型训练之难众所周知，其中一个重要的现象就是Internal Covariate Shift. Batch Norm 大法自2015年由Google提出之后，就成为深度学习必备之神器。自BN之后，Layer Norm/ Weight Norm/ Cosine Norm 等也横空出世。本文从Normalization的背景讲起，用一个公式概括Normalization的基本思想与通用框架，将各大主流方法一一对号入座进行深入的对比分析，并从参数和数据的伸缩不变性的角度探讨Normalization有效的深层原因。<br/></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>为什么需要Normalization<br>———深度学习中的 Internal Covariate Shift 问题极其影响</li><li>Normalization的通用框架与基本思想<br>———从主流Normalization方法中提炼出的抽象框架</li><li>主流 Normalization 方法梳理<br>———结合上述框架，将 BatchNorm/ LayerNorm/ WeightNorm/ CosineNorm 对号入座，各种方法之间的异同水落石出。</li><li>Normalization 为什么会有效？<br>———从参数和数据的伸缩不变性探讨Normalization有效的深层原因。<br>以下是正文，enjoy.</li></ol><h3 id="1-为什么需要Normalization"><a href="#1-为什么需要Normalization" class="headerlink" title="1. 为什么需要Normalization"></a>1. 为什么需要Normalization</h3><h4 id="1-1-独立同分布与白化"><a href="#1-1-独立同分布与白化" class="headerlink" title="1.1 独立同分布与白化"></a>1.1 独立同分布与白化</h4><p>  机器学习界的炼丹师们最喜欢的数据有什么特点？窃以为，莫过于“<strong>独立同分布</strong>”了, 即<em>independent and identically distributed</em>, 简称为 <em>i.i.d.</em> 独立同分布并非所有机器学习模型的必然要求（比如 Naive Bayes 模型就建立在特征彼此独立的基础之上，而Logistic Regression 和神经网络则在非独立的特征数据上依然可以训练出很好的模型），但独立同分布的数据可以简化常规学习模型的训练、提升机器学习模型的预测能力，已经是一个共识。</p><p>因此，在把数据喂给机器学习模型之前， “<strong>白化（whitening）</strong>”是一个重要的数据预处理步骤。白化一般包含两个目的：<br>（1）<em>去除特征之间的相关性</em>  —&gt; 独立；<br>（2）<em>使得所有特征具有相同的均值和方差</em>  —&gt; 同分布。</p><p>白化最典型的方法就是PCA， 可以参考阅读 PCA Whitening (<a href="http://ufldl.stanford.edu/tutorial/unsupervised/PCAWhitening/">http://ufldl.stanford.edu/tutorial/unsupervised/PCAWhitening/</a>)</p><h4 id="1-2-深度学习中的Internal-Covariate-Shift"><a href="#1-2-深度学习中的Internal-Covariate-Shift" class="headerlink" title="1.2 深度学习中的Internal Covariate Shift"></a>1.2 深度学习中的Internal Covariate Shift</h4><p>深度神经网络模型的训练为什么会很困难？其中一个重要的原因是，深度神经网络涉及到很多层的叠加，而每一层的参数更新会导致上层的输入数据分布发生变化，通过层层叠加，高层的输入分布变化会非常剧烈，这就使得高层需要不断去重新适应底层的参数更新。为了训好模型，我们需要非常谨慎地去设定学习率、初始化权重、以及尽可能细致地参数更新策略。<br>Google将这一现象总结为Internal Covariate Shift， 简称ICS, 什么是ICS呢？</p><p>大家都知道统计机器学习中地一个经典假设是“<strong>源空间</strong>（source domain）和<strong>目标空间</strong>（target domain）的数据分布（distribution）是一致的”。如果不一致，那么就出现了新的机器学习问题，如transfer learning/ domain adaptation等。而covariate shift就是分布不一致假设之下的一个分支问题，它是指源空间和目标空间的条件概率是一致的，但是其边缘概率不同，即：对所有$x\in X_1P_s(Y|X=x)=P_t(Y|X=x)$但是$P_s(X)\neq P_t(X)$ 大家细想便会发现，的确，对于神经网络的各层输出，由于它们经过了层内操作作用，其分布显然与各层对应的输入信号分布不同，而且差异会随着网络深度增大而增大，可是它们所能“指示”的样本标记（label）仍然是不变的，这便符合了covariate shift的定义。由于是对层间信号的分析，也即是“internal”的来由。</p><h4 id="1-3-ICS会导致什么问题？"><a href="#1-3-ICS会导致什么问题？" class="headerlink" title="1.3  ICS会导致什么问题？"></a>1.3  ICS会导致什么问题？</h4><p>简而言之，每个神经元的输入数据不再是“独立同分布”。<br>其一，上层参数需要不断适应新的输入数据分布，降低学习速度。<br>其二，下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止。<br>其三，每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能地谨慎。</p><h3 id="2-Normalization-的通用框架与基本思想"><a href="#2-Normalization-的通用框架与基本思想" class="headerlink" title="2. Normalization 的通用框架与基本思想"></a>2. Normalization 的通用框架与基本思想</h3><p>我们以神经网络中的一个普通神经元为例。神经元接收一组输入向量$\textbf x=(x_1, x_2, …, x_d)$ 通过某种运算后，输出一个标量值：$y=f(\textbf x)$ 。</p><p>由于ICS问题的存在，$\textbf x$ 的分布可能相差很大。要解决独立同分布的问题，“理论正确”的方法就是对每一层的数据都进行白化操作。然而标准的白化操作代价高昂，特别是我们还希望白化操作可微的，保证白化操作可以通过反向传播来更新梯度。</p><p>因此，以BN为代表的 Normalization 方法退而求其次，进行了简化的白化操作。基本思想是：在将$\textbf x$ 送给神经元之前，先对其做平移和伸缩变换，将$\textbf x$ 的分布规范化成在固定区间范围的标准分布。</p><p>通用变换框架就如下所示：</p><script type="math/tex; mode=display">h=f(g\cdot\frac{x-\mu}{\sigma}+b)</script><p>我们来看看这个公式中的各个参数。</p><p>（1）$\mu$是平移参数（shift parameter），$\sigma$是缩放参数（scale parameter）。通过这两个参数进行shift和scale变换：</p><script type="math/tex; mode=display">\hat{\textbf x}=\frac{\textbf x - \mu}{\sigma}</script><p>数据符合均值为0、方差为1的标准分布。<br>（2）$\textbf b$是再平移参数（re-shift parameter），$\textbf g$是再缩放参数（re-scale parameter）。将上一步得到的$\hat{\textbf x}$ 进一步变换为：</p><script type="math/tex; mode=display">\textbf y = \textbf g\cdot \hat{\textbf x} + \textbf b</script><p>最终得到的数据符合均值为$\textbf b$、方差为 $\textbf g^2$ 的分布。<br>奇不奇怪？奇不奇怪？</p><p>说好的处理ICS，第一步都已经得到了标准分布，第二步怎么又给变走了？<br>答案是——<strong>为了保证模型的表达能力不因规范化而下降</strong></p><p>我们可以看到，第一步的变换将输入数据限制到了一个全局统一的确定范围（均值为0、方差为1）。下层神经元可能很努力地在学习，但不论其如何变化，其输出的结果在交给上层神经元进行处理之前，将被粗暴地重新调整到这一固定范围。<br>沮不沮丧？沮不沮丧？<br>难道我们底层神经元人民就在做无用功吗？ </p><p>所以，为了尊重底层神经网络的学习结果，我们将规范化后的数据进行再平移和再缩放，使得每个神经元对应的输入范围是针对该神经元量身定制的一个确定范围（均值为$\textbf b$、方差为$\textbf g^2$）。rescale和reshift的参数都是可学习的，这就使得Normalization层可以学习如何去尊重底层的学习结果。</p><p>除了充分利用底层学习的能力，另一方面的重要意义在于保证获得非线性的表达能力。Sigmoid等激活函数在神经网络中有着重要作用，通过区分饱和区和非饱和区，使得神经网络的数据变换具有了非线性计算能力。而第一步的规范化会将几乎所有数据映射到激活函数的非饱和区（线性区），仅利用到了线性变化的能力，从而降低了神经网络的表达能力。而进行再变换，则可以将数据从线性区变换到非线性区，恢复模型的表达能力。</p><p>那么问题又来了——<br><strong>经过这么的变回来再变过去，会不会跟没变一样？</strong></p><p>不会。因为，再变换引入的两个新参数$\textbf g$和$\textbf b$，可以表示旧参数作为输入的同一族函数，但是新参数有不同的学习动态。在旧参数中，$\textbf x$的均值取决于下层神经网络的复杂关联；但在新参数中，$\textbf y = \textbf g \cdot \hat{\textbf x} + \textbf b$ 仅由</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Normalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/4a17b156.html"/>
      <url>posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
